# 图论

## LCA

+ 倍增

```cpp

int N, M, S;
int fa[maxn][31], dep[maxn];
//fa[i][j]：第i个点的第2^j个祖先
vector<int> G[maxn];

void dfs(int root,int fno)
{
    fa[root][0] = fno;
    dep[root] = dep[fno] + 1;
    //初始化fa
    for(int i = 1; i < 31; ++i)
    {
        fa[root][i] = fa[fa[root][i-1]][i-1];
    }
    //遍历
    for(auto y : G[root])
    {
        if(y == fno) continue;
        dfs(y, root);
    }
}

int lca(int x, int y)
{
    if(dep[x] > dep[y]) swap(x,y);
    int tem = dep[y] - dep[x];
    for(int i = 0; tem; ++i, tem >>= 1)
    {
        if(tem&1) y = fa[y][i];
    }
    if(y == x) return x;
    for(int i = 30; i >= 0 && y != x; --i)
    {
        if(fa[x][i] != fa[y][i])
        {
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    return fa[x][0];
}
```

```cpp
void dfs(int u, int fa) {
    pa[u][0] = fa; dep[u] = dep[fa] + 1;
    FOR (i, 1, SP) pa[u][i] = pa[pa[u][i - 1]][i - 1];
    for (int& v: G[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int t = dep[u] - dep[v];
    FOR (i, 0, SP) if (t & (1 << i)) u = pa[u][i];
    FORD (i, SP - 1, -1) {
        int uu = pa[u][i], vv = pa[v][i];
        if (uu != vv) { u = uu; v = vv; }
    }
    return u == v ? u : pa[u][0];
}
```

## 欧拉路径
```cpp
//欧拉回路 1有向图 2无向图
int tsk, n, m;
int head[maxn], nxt[maxm], to[maxm], tote;
int ind[maxn], outd[maxn];
void addedge(int u, int v)
{
    nxt[++tote] = head[u];
    head[u] = tote;
    to[tote] = v;
}
int getegs(int rt)
{
    return ind[rt] + outd[rt];
}

int fa[maxn], rk[maxn];
vector<int> path;
int skt[maxm], top = 0;
inline void init(){for(int i=0;i<=n;i++){fa[i]=i;rk[i]=1;}}
int find(int x) {return fa[x]==x?x:(fa[x]=find(fa[x]));}
inline void merge(int i, int j)
{
    int x = find(i), y = find(j);
    if(rk[x] <= rk[y]) fa[x] = y;
    else fa[y] = x;
    if(rk[x] == rk[y] && x != y) rk[y]++;
}

int vis[maxm];
void dfs1(int u)
{
    for(int &e = head[u]; e; e = nxt[e])
    {
        if(vis[e>>1]) continue;int t = e;
        vis[t>>1] = 1;dfs1(to[t]);
        path.push_back(t&1?-(t>>1):t>>1);
    }
}

void task1()
{
    tote = 1;
    mst(vis);
    for(int i = 1; i <= m; i++)
    {
        int u, v;
        cin>>u>>v;
        addedge(u,v);
        addedge(v,u);
        ind[v]++;outd[u]++;
        merge(u,v);
    }
    int ori = -1, f = 1;
    for(int i = 1; i <= n; i++)
    {
        int qwq = getegs(i);
        if(qwq == 0) continue;
        if(qwq & 1) f = 0;
        if(ori == -1) ori = i;
        if(find(ori) != find(i)) f = 0;
    }
    if(f==0) {cout<<"NO"<<endl; return;}
    else cout<<"YES"<<endl;
    if(ori != -1)
    {
        dfs1(ori);
        for(int i = path.size() - 1; i >= 0; i--)
        {
            cout<<path[i]<<" ";
        }
        cout<<endl;
    }
}

void dfs2(int rt)
{
    for(int &e = head[rt]; e; e = nxt[e])
    {
        if(vis[e]) continue;int t = e;
        vis[e] = 1;
        dfs2(to[e]);
        skt[++top] = t;
    }
}

void task2()
{
    tote = 0;
    for(int i = 1; i <= m; i++)
    {
        int u, v;
        cin>>u>>v;
        addedge(u,v);
        merge(u,v);
        ind[v]++;outd[u]++;
    }
    int ori = -1, f = 1;
    for(int i = 1; i <= n; i++)
    {
        int qwq = getegs(i);
        if(qwq == 0) continue;
        if(ind[i] != outd[i]) f = 0;
        if(ori == -1) ori = i;
        if(find(ori) != find(i)) f = 0;
    }
    if(f == 0) {cout<<"NO"<<endl;return;}
    else cout<<"YES"<<endl;
    if(ori != -1)
    {
        dfs2(ori);
        for(int i = m; i >= 1; i--) cout<<skt[i]<<" ";
        cout<<endl;
        // for(int i = path.size() - 1; i >= 0; i--)
        // cout<<path[i]<<" ";
        // cout<<endl;
    }
}
```
```cpp
int S[N << 1], top;
Edge edges[N << 1];
set<int> G[N];

void DFS(int u) {
    S[top++] = u;
    for (int eid: G[u]) {
        int v = edges[eid].get_other(u);
        G[u].erase(eid);
        G[v].erase(eid);
        DFS(v);
        return;
    }
}

void fleury(int start) {
    int u = start;
    top = 0; path.clear();
    S[top++] = u;
    while (top) {
        u = S[--top];
        if (!G[u].empty())
            DFS(u);
        else path.push_back(u);
    }
}
```

## 强连通分量与 2-SAT

```cpp
//2-sat

int n, m;//n人1~n(1&2同党) m关系
int oth(int x) {return x%2?x+1:x-1;}//另一个人
vector<int> e[maxn];//存边

int dfn[maxn], low[maxn], dfncnt;
int tj_stack[maxn], in_stack[maxn], tp;
int scc[maxn], scc_cnt;
void tarjan(int rt)
{
    dfn[rt] = low[rt] = ++dfncnt;
    tj_stack[++tp] = rt, in_stack[rt] = 1;
    for(int i = 0; i < e[rt].size(); i++)
    {
        int y = e[rt][i];
        if(!dfn[y])
        {
            tarjan(y);
            low[rt] = min(low[rt], low[y]);
        }
        else if(in_stack[y]) low[rt] = min(low[rt], dfn[y]);
    }
    if(dfn[rt] == low[rt])
    {
        ++scc_cnt;
        while(tj_stack[tp] != rt)
        {
            scc[tj_stack[tp]] = scc_cnt;
            in_stack[tj_stack[tp]] = 0;
            tp--;
        }
        scc[tj_stack[tp]] = scc_cnt;
        in_stack[tj_stack[tp]] = 0;
        tp--;
    }
}

void init()
{
    mst(dfn);
    mst(low);
    dfncnt=0;
    tp = 0;
    for(int i = 1; i <= n; i++) e[i].clear();
    mst(scc);
    scc_cnt = 0;
    mst(tj_stack);
    mst(in_stack);
}

int main()
{
    // freopen("D:/c++source file/intxt/in.txt","r",stdin);
    ios :: sync_with_stdio(0);
    cin.tie(0);
    
    while(cin>>n>>m)
    {
        n *= 2;
        init();
        
        for(int i = 1; i <= m; i++)
        {
            int u, v;
            cin>>u>>v;
            e[u].push_back(oth(v));
            e[v].push_back(oth(u));
        }
        for(int i = 1; i <= n; i++)
        {
            if(!dfn[i]) tarjan(i);
        }
        int f = 0;
        for(int i = 1; i <= n; i+=2)
        {
            if(scc[i] == scc[oth(i)])
            {
                cout<<"NIE"<<endl;
                f = 1;
                break;
            }
        }
        if(f) continue;
        for(int i = 1; i <= n; i+=2)
        {
            cout<<(scc[i] > scc[oth(i)] ? oth(i) : i)<<endl;
        }
    }
    
    
    //cerr<<"Time : "<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms";
    return (0);
    /*
    先tarjan缩点 然后检查行不行 然后直接输出
    */
}
```


```cpp
int n, m;
vector<int> G[N], rG[N], vs;
int used[N], cmp[N];

void add_edge(int from, int to) {
    G[from].push_back(to);
    rG[to].push_back(from);
}

void dfs(int v) {
    used[v] = true;
    for (int u: G[v]) {
        if (!used[u])
            dfs(u);
    }
    vs.push_back(v);
}

void rdfs(int v, int k) {
    used[v] = true;
    cmp[v] = k;
    for (int u: rG[v])
        if (!used[u])
            rdfs(u, k);
}

int scc() {
    memset(used, 0, sizeof(used));
    vs.clear();
    for (int v = 0; v < n; ++v)
        if (!used[v]) dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = (int) vs.size() - 1; i >= 0; --i)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}

int main() {
    cin >> n >> m;
    n *= 2;
    for (int i = 0; i < m; ++i) {
        int a, b; cin >> a >> b;
        add_edge(a - 1, (b - 1) ^ 1);
        add_edge(b - 1, (a - 1) ^ 1);
    }
    scc();
    for (int i = 0; i < n; i += 2) {
        if (cmp[i] == cmp[i + 1]) {
            puts("NIE");
            return 0;
        }
    }
    for (int i = 0; i < n; i += 2) {
        if (cmp[i] > cmp[i + 1]) printf("%d\n", i + 1);
        else printf("%d\n", i + 2);
    }
}
```

## 拓扑排序
```cpp
vector<int> G[MAXN];  // vector 实现的邻接表
int c[MAXN];          // 标志数组
vector<int> topo;     // 拓扑排序后的节点

bool dfs(int u) {
  c[u] = -1;
  for (int v : G[u]) {
    if (c[v] < 0)
      return false;
    else if (!c[v])
      if (!dfs(v)) return false;
  }
  c[u] = 1;
  topo.push_back(u);
  return true;
}

bool toposort() {
  topo.clear();
  memset(c, 0, sizeof(c));
  for (int u = 0; u < n; u++)
    if (!c[u])
      if (!dfs(u)) return false;
  reverse(topo.begin(), topo.end());
  return true;
}
```

```cpp
vector<int> toporder(int n) {
    vector<int> orders;
    queue<int> q;
    for (int i = 0; i < n; i++)
        if (!deg[i]) {
            q.push(i);
            orders.push_back(i);
        }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v: G[u])
            if (!--deg[v]) {
                q.push(v);
                orders.push_back(v);
            }
    }
    return orders;
}
```

## Tarjan

### 割点

+ 判断割点
+ 注意原图可能不连通

```cpp
int dfn[N], low[N], clk;
void init() { clk = 0; memset(dfn, 0, sizeof dfn); }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int cc = fa != -1;
    for (int& v: G[u]) {
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            cc += low[v] >= dfn[u];
        } else low[u] = min(low[u], dfn[v]);
    }
    if (cc > 1) // ...
}
```

### 桥

+ 注意原图不连通和重边

```cpp
int dfn[N], low[N], clk;
void init() { memset(dfn, 0, sizeof dfn); clk = 0; }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int _fst = 0;
    for (E& e: G[u]) {
        int v = e.to; if (v == fa && ++_fst == 1) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            if (low[v] > dfn[u]) // ...
            low[u] = min(low[u], low[v]);
        } else low[u] = min(low[u], dfn[v]);
    }
}
```

### 强连通分量缩点

```cpp

int n, m;
int val_ori[maxn];
vector<int> e_ori[maxn], e_scc[maxn];

int dfn[maxn], low[maxn], dfncnt, tj_stack[maxn], in_stack[maxn], tp;
int scc[maxn], scc_cnt, val_scc[maxn];//属于哪个scc 一共多少scc 缩点后权值和
//编号从1开始
void tarjan(int rt)
{
    dfn[rt] = low[rt] = ++dfncnt;
    tj_stack[++tp] = rt, in_stack[rt] = 1;
    for(auto y : e_ori[rt])
    {
        if(!dfn[y])
        {
            tarjan(y);
            low[rt] = min(low[rt], low[y]);
        }
        else if(in_stack[y]) low[rt] = min(low[rt], dfn[y]);
    }
    if(dfn[rt] == low[rt])
    {
        ++scc_cnt;
        while(tj_stack[tp] != rt)
        {
            scc[tj_stack[tp]] = scc_cnt;
            in_stack[tj_stack[tp]] = 0;
            val_scc[scc_cnt] += val_ori[tj_stack[tp]];
            tp--;
        }
        scc[tj_stack[tp]] = scc_cnt;
        in_stack[tj_stack[tp]] = 0;
        val_scc[scc_cnt] += val_ori[tj_stack[tp]];
        tp--;
    }
}

int dp[maxn];//当前节点出发最大权值
void search_dp(int rt)
{
    dp[rt] = val_scc[rt];
    int maxv = 0;
    for(auto y : e_scc[rt])
    {
        if(!dp[y]) search_dp(y);
        maxv = max(maxv, dp[y]);
    }
    dp[rt] = dp[rt] + maxv;
}

int main()
{
    // freopen("D:/c++source file/intxt/in.txt","r",stdin);
    ios :: sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    for(int i = 1; i <= n; i++) cin>>val_ori[i];
    for(int i = 1; i <= m; i++)
    {
        int u, v;
        cin>>u>>v;
        e_ori[u].push_back(v);
    }
    for(int i = 1; i <= n; i++)
    {
        if(!dfn[i])
        {
            tarjan(i);
        }
    }
    for(int i = 1; i <= n; i++)
    {
        for(auto y : e_ori[i])
        {
            if(scc[i] != scc[y])//注意tarjan完了逆拓扑序建反图
            {
                e_scc[scc[i]].push_back(scc[y]);
            }
        }
    }
    int ans = 0;
    for(int i = 1; i <= scc_cnt; i++)
    {
        if(!dp[i])
        {
            search_dp(i);
            ans = max(dp[i], ans);
        }
    }
    cout<<ans<<endl;
    
    // cerr<<"Time : "<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms";
    return (0);
}
```

```cpp
int low[N], dfn[N], clk, B, bl[N];
vector<int> bcc[N];
void init() { B = clk = 0; memset(dfn, 0, sizeof dfn); }
void tarjan(int u) {
    static int st[N], p;
    static bool in[N];
    dfn[u] = low[u] = ++clk;
    st[p++] = u; in[u] = true;
    for (int& v: G[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        while (1) {
            int x = st[--p]; in[x] = false;
            bl[x] = B; bcc[B].push_back(x);
            if (x == u) break;
        }
        ++B;
    }
}
```

## 最小生成树及
```cpp
//唯一
struct edge{
    int from, to, val;
}e[maxn];
int n, m, ans;
int fa[maxn];
bool cmp(edge a, edge b){return a.val < b.val;}
void init()
{
    for(int i = 0; i <= n; i++)
    {
        fa[i] = i;
    }
    ans = 0;
}
int find(int x) {return fa[x]==x?x:(fa[x] = find(fa[x]));}
bool uniKruskal()
{
    int sum1 = 0, sum2 = 0;//已使用的 可能使用的
    int p = 0;//相同指针
    int flag = 0, num = 0;
    for(int i = 1; i <= m + 1; i++)
    {
        if(p<i)
        {
            if(sum1 != sum2)
            {
                flag = 1;
                break;
            }
            sum1 = 0, sum2 = 0;
            for(int j = i; j <= m+1; j++)
            {
                if(e[j].val != e[i].val)
                {
                    p = j-1;
                    break;
                }
                if(find(e[j].from) != find(e[j].to))
                ++sum2;
            }
        }
        if(i>m) break;
        int x = find(e[i].from);
        int y = find(e[i].to);
        if(x != y && num != n-1)
        {
            num++;
            sum1++;
            // merge(x, y);
            fa[x] = fa[y];
            ans += e[i].val;
        }
    }
    if(flag) return false;
    else return true;
}

int main()
{
    freopen("D:/c++source file/intxt/in.txt","r",stdin);
    // ios :: sync_with_stdio(0);
    // cin.tie(0);
    cf
    {
        cin>>n>>m;
        init();
        for(int i = 1; i <= m; i++) cin>>e[i].from>>e[i].to>>e[i].val;
        sort(e+1,e+1+m, cmp);
        if(uniKruskal()) cout<<ans<<endl;
        else cout<<"Not Unique!"<<endl;
    }
    
    
    //cerr<<"Time : "<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms";
    return (0);
}
```

## Dijk最短路
```cpp

namespace Dijk
{
    const int maxm = 5e5;
    const int inff = 2147483647;
    int n, m, s;
    int dis[maxn], vis[maxn];//距离 是否在集合里
    struct edge{
        int v, w;
        edge(int b, int c):v(b),w(c){}
    };
    struct node{
        int dis, u;
        bool operator > (const node a) const {return dis>a.dis;}
    };
    vector<edge> e[maxm];
    struct Dijkstra
    {
        void init()//输入数据 重置
        {
            cin>>n>>m>>s;
            for(int i = 0; i <= m; i++) e[i].clear();
            for(int i = 0; i <= n; i++) dis[i] = inff;
            memset(vis, 0, sizeof(vis));
            for(int i = 1; i <= m; i++)
            {
                int a, b, c;
                cin>>a>>b>>c;
                e[a].push_back(edge(b,c));
            }
        }
        void work()//Dijk
        {
            dis[s] = 0;
            priority_queue<node, vector<node>, greater<node> > q;
            q.push({0, s});
            while(!q.empty())
            {
                int x = q.top().u;q.pop();
                if(vis[x]) continue;
                vis[x] = 1;
                for(int i = 0; i < e[x].size(); i++)
                {
                    int to = e[x][i].v, w = e[x][i].w;
                    if(dis[to] > dis[x] + w)
                    {
                        dis[to] = dis[x] + w;
                        q.push({dis[to], to});
                    }
                }
            }
        }
    };
}

int main()
{
    // freopen("D:/c++source file/intxt/in.txt","r",stdin);
    ios :: sync_with_stdio(0);
    cin.tie(0);
    Dijk::Dijkstra a;
    a.init();
    a.work();
    for(int i = 1; i <= Dijk::n; i++)
    {
        cout<<Dijk::dis[i]<<' ';
    }
    
    
    //cerr<<"Time : "<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms";
    return (0);
}
```