# 数据结构

## 线段树
```
#define mid ((l + r) / 2)
#define lson (rt << 1)
#define rson (rt << 1 | 1)
```
+ 普适

```cpp

int a[maxn];
struct node {
    int len, val;//长度 数量
    int s, t, pl, el;//第一个 最后一个 前缀上升长度 后缀上升长度
}tree[maxn<<2];

node Merge(node a, node b) {
    node res;
    res.pl = a.pl;
    res.el = b.el;
    res.s = a.s;
    res.t = b.t;
    res.len = a.len + b.len;
    res.val = a.val + b.val;
    if(a.t > b.s) return res;
    if(a.pl == a.len) res.pl = a.len + b.pl;
    if(b.el == b.len) res.el = a.el + b.len;
    res.val += a.el * b.pl;
    return res;
}

void update(int rt) {
    tree[rt] = Merge(tree[lson], tree[rson]);
}

void build(int l, int r,int rt) {
    if(l == r){
        tree[rt].len = 1;
        tree[rt].val = 1;
        tree[rt].s = tree[rt].t = a[l];
        tree[rt].el = tree[rt].pl = 1;
        return ;
    }
    build(l, mid, lson);
    build(mid+1, r, rson);
    update(rt);
}

void modify(int l, int r, int rt, int x, int y) {
    if(l == r) {
        tree[rt].s = tree[rt].t = y;
        return ;
    }
    if(x <= mid) modify(l, mid, lson, x, y);
    else modify(mid+1, r, rson, x, y);
    update(rt);
}

node query(int l, int r, int rt, int L, int R) {
    if(L <= l && r <= R) return tree[rt];
    node tmp;
    tmp.len = -1;
    if(L <= mid) tmp = query(l ,mid, lson, L, R);
    if(mid < R) {
        if(tmp.len == -1) tmp = query(mid+1, r, rson, L, R);
        else tmp = Merge(tmp, query(mid+1, r, rson, L, R));
    }
    return tmp;
}
```

+加法乘法

```cpp

int n, m, md;
int a[maxn];
struct node{
    int val;
    int add, mult;
}tree[maxn<<2];

void buildtree(int l, int r, int rt) {
    if(l == r) {
        tree[rt].val = a[l];
        tree[rt].add = 0;
        tree[rt].mult = 1;
        tree[rt].val %= md;
        return ;
    }

    buildtree(l, mid, lson);
    buildtree(mid+1, r, rson);
    tree[rt].add = 0;
    tree[rt].mult = 1;
    tree[rt].val = tree[lson].val + tree[rson].val;
    tree[rt].val %= md;
    return ;
}
//先乘再加
void pushdown(int l, int r, int rt) {
    tree[lson].val = (tree[lson].val * tree[rt].mult + tree[rt].add * (mid-l+1)) % md;
    tree[lson].add = (tree[lson].add * tree[rt].mult + tree[rt].add) % md;
    tree[lson].mult = (tree[lson].mult * tree[rt].mult) % md;
    
    tree[rson].val = (tree[rson].val * tree[rt].mult + tree[rt].add * (r-mid)) % md;
    tree[rson].add = (tree[rson].add * tree[rt].mult + tree[rt].add) % md;
    tree[rson].mult = (tree[rson].mult * tree[rt].mult) % md;

    tree[rt].add = 0;
    tree[rt].mult = 1;
    return ;
}

int query(int l, int r, int rt, int L, int R) {
    if(L > r || R < l) return 0;
    if(l >= L && r <= R) {return tree[rt].val;}

    pushdown(l, r, rt);
    return query(l, mid, lson, L, R) + query(mid+1, r, rson, L, R);
}

void add(int l, int r, int rt, int L, int R, int val) {
    if(L > r || R < l) return ;
    if(l >= L && r <= R) {
        tree[rt].add += val;
        tree[rt].val += val * (r-l+1);
        tree[rt].val %= md;
        return ;
    }
    pushdown(l,r,rt);
    add(l, mid, lson, L, R, val);
    add(mid+1, r, rson, L, R, val);
    tree[rt].val = tree[lson].val + tree[rson].val;
        tree[rt].val %= md;
    return ;
}

void mult(int l, int r, int rt, int L, int R, int val) {
    if(L > r || R < l) return ;
    if(l >= L && r <= R) {
        pushdown(l, r, rt);
        tree[rt].mult *= val;
        tree[rt].val *= val;
        tree[rt].val %= md;
        return ;
    }

    pushdown(l, r, rt);
    mult(l, mid, lson, L, R, val);
    mult(mid+1, r, rson, L, R, val);
    tree[rt].val = tree[lson].val + tree[rson].val;
        tree[rt].val %= md;
}
```

## 树状数组

* 注意：0 是无效下标

```cpp
int tree[maxn];
int n;
int lowbit(int x) {return x & -x;}
void add(int pos, int val)
{
    while(pos <= n)
    {
        tree[pos] += val;
        pos += lowbit(pos);
    }
}
int sum(int pos)
{
    int ans = 0;
    while(pos)
    {
        ans += tree[pos];
        pos -= lowbit(pos);
    }
    return ans;
}
```

+ 区间修改 & 区间查询（单点修改，查询前缀和的前缀和）

```cpp
int tree1[maxn], tree2[maxn];
int n, q;
int lowbit(int x) {return x & -x;}
inline int read(){
    int x=0,f=1,c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return f==1?x:-x;
}
void add(int pos, int val)
{
    int addval = val * pos;
    while(pos <= n)
    {
        tree1[pos] += val;
        tree2[pos] += addval;
        pos += lowbit(pos);
    }
}
int sum1(int pos)
{
    // cout<<"sum1:"<<pos<<"=";
    int ans = 0;
    while(pos)
    {
        ans += tree1[pos];
        pos -= lowbit(pos);
    }
    // cout<<ans<<"\n";
    return ans;
}
int sum2(int pos)
{
    // cout<<"sum2:"<<pos<<"=";
    int ans = 0;
    while(pos)
    {
        ans += tree2[pos];
        pos -= lowbit(pos);
    }
    // cout<<ans<<endl;
    return ans;
}
int sum(int pos){return sum1(pos) * (pos + 1) - sum2(pos);}
void modify(int l, int r, int val)
{
    add(l ,val);
    add(r+1, -val);
}
```
+ 二维树状数组 单点修改

```cpp

int tree[maxn][maxn];
int xn, yy;
int lowbit(int x) {
    return x & -x;
}
void add(int x, int y, int val) {
    int my = y;

    while (x <= xn) {
        y = my;

        while (y <= yy) {
            tree[x][y] += val;
            y += lowbit(y);
        }

        x += lowbit(x);
    }
}

int getsum(int x, int y) {
    int ans = 0;
    int my = y;

    while (x) {
        y = my;

        while (y) {
            ans += tree[x][y];
            y -= lowbit(y);
        }

        x -= lowbit(x);
    }

    return ans;
}
int q_get(int x1, int y1, int x2, int y2) {
    int ans = 0;
    ans += getsum(x2, y2);
    ans -= getsum(x1 - 1, y2);
    ans -= getsum(x2, y1 - 1);
    ans += getsum(x1 - 1, y1 - 1);
    return ans;
}
```

+ 区间修改区间查询二维树状数组
```cpp

int lowbit(int x) {return x & -x;}
void add(int x, int y, int val)
{
    // cout<<x<<" "<<y<<" "<<val<<endl;
    int memoy = y, memox = x;
    while(x <= n)
    {
        y = memoy;
        while(y <= m)
        {
            t1[x][y] += val;
            t2[x][y] += val * memoy;
            t3[x][y] += val * memox;
            t4[x][y] += val * memox * memoy;
            y += lowbit(y);
        }
        x += lowbit(x);
    }
}

int ask(int x, int y)
{
    int ans = 0;
    int memoy = y, memox = x;
    while(x)
    {
        y = memoy;
        while(y)
        {
            ans += (memoy+1)*(memox+1)*t1[x][y];
            ans -= t2[x][y] * (memox + 1);
            ans -= t3[x][y] * (memoy + 1);
            ans += t4[x][y];
            y -= lowbit(y);
        }
        x -= lowbit(x);
    }
    return ans;
}

void range_add(int xx1, int yy1, int xx2, int yy2, int val)
{
    add(xx1,yy1, val);
    add(xx1, yy2 + 1, -val);
    add(xx2 + 1, yy1, -val);
    add(xx2+1,yy2+1,val);
}

int range_ask(int xx1, int yy1, int xx2, int yy2)
{
    int ans = 0;
    ans += ask(xx1-1,yy1-1);
    ans -= ask(xx1-1,yy2);
    ans -= ask(xx2, yy1-1);
    ans += ask(xx2, yy2);
    return ans;
}
```

## 并查集

```cpp
int n, m;
int fa[maxn], rk[maxn];
inline void init(){for(int i=0;i<=n;i++){fa[i]=i;rk[i]=1;}}
int find(int x) {return fa[x]==x?x:(fa[x]=find(fa[x]));}
inline void merge(int i, int j)
{
    int x = find(i), y = find(j);
    if(rk[x] <= rk[y]) fa[x] = y;
    else fa[y] = x;
    if(rk[x] == rk[y] && x != y) rk[y]++;
}
```